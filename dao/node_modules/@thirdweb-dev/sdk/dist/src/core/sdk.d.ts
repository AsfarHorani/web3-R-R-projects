import { ContractInterface } from "ethers";
import { IStorage } from "@thirdweb-dev/sdk/dist/src/core/interfaces/IStorage";
import { Edition, EditionDrop, Marketplace, NFTCollection, NFTDrop, Pack, Split, Token, Vote } from "@thirdweb-dev/sdk/dist/src/contracts";
import { SDKOptions } from "@thirdweb-dev/sdk/dist/src/schema/sdk-options";
import { RPCConnectionHandler } from "@thirdweb-dev/sdk/dist/src/core/classes/rpc-connection-handler";
import type { ContractForContractType, ContractType, NetworkOrSignerOrProvider } from "@thirdweb-dev/sdk/dist/src/core/types";
import { ContractDeployer } from "@thirdweb-dev/sdk/dist/src/core/classes/contract-deployer";
import { SmartContract } from "@thirdweb-dev/sdk/dist/src/contracts/smart-contract";
import { TokenDrop } from "@thirdweb-dev/sdk/dist/src/contracts/token-drop";
import { ContractPublisher } from "@thirdweb-dev/sdk/dist/src/core/classes/contract-publisher";
import { UserWallet } from "@thirdweb-dev/sdk/dist/src/core/wallet/UserWallet";
/**
 * The main entry point for the thirdweb SDK
 * @public
 */
export declare class ThirdwebSDK extends RPCConnectionHandler {
    /**
     * @internal
     * the cache of contracts that we have already seen
     */
    private contractCache;
    /**
     * @internal
     * should never be accessed directly, use {@link ThirdwebSDK.getPublisher} instead
     */
    private _publisher;
    /**
     * Upload and download files
     */
    storage: IStorage;
    /**
     * New contract deployer
     */
    deployer: ContractDeployer;
    /**
     * Interact with the connected wallet
     */
    wallet: UserWallet;
    constructor(network: NetworkOrSignerOrProvider, options?: SDKOptions, storage?: IStorage);
    /**
     * Get an instance of a Drop contract
     * @param contractAddress - the address of the deployed contract
     * @returns the contract
     */
    getNFTDrop(contractAddress: string): NFTDrop;
    /**
     * Get an instance of a NFT Collection contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getNFTCollection(address: string): NFTCollection;
    /**
     * Get an instance of a Edition Drop contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getEditionDrop(address: string): EditionDrop;
    /**
     * Get an instance of an Edition contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getEdition(address: string): Edition;
    /**
     * Get an instance of a Token Drop contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getTokenDrop(address: string): TokenDrop;
    /**
     * Get an instance of a Token contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getToken(address: string): Token;
    /**
     * Get an instance of a Vote contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getVote(address: string): Vote;
    /**
     * Get an instance of a Splits contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getSplit(address: string): Split;
    /**
     * Get an instance of a Marketplace contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getMarketplace(address: string): Marketplace;
    /**
     * Get an instance of a Pack contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getPack(address: string): Pack;
    /**
     *
     * @internal
     * @param address - the address of the contract to instantiate
     * @param contractType - optional, the type of contract to instantiate
     * @returns a promise that resolves with the contract instance
     */
    getBuiltInContract<TContractType extends ContractType = ContractType>(address: string, contractType: TContractType): ContractForContractType<TContractType>;
    /**
     * @param contractAddress - the address of the contract to attempt to resolve the contract type for
     * @returns the {@link ContractType} for the given contract address
     * @throws if the contract type cannot be determined (is not a valid thirdweb contract)
     */
    resolveContractType(contractAddress: string): Promise<ContractType>;
    /**
     * Return all the contracts deployed by the specified address
     * @param walletAddress - the deployed address
     */
    getContractList(walletAddress: string): Promise<{
        address: string;
        contractType: "split" | "custom" | "token" | "pack" | "edition" | "edition-drop" | "token-drop" | "vote" | "marketplace" | "nft-drop" | "nft-collection";
        metadata: () => Promise<any>;
    }[]>;
    /**
     * Update the active signer or provider for all contracts
     * @param network - the new signer or provider
     */
    updateSignerOrProvider(network: NetworkOrSignerOrProvider): void;
    private updateContractSignerOrProvider;
    /**
     * Get an instance of a Custom ThirdwebContract
     * @param address - the address of the deployed contract
     * @returns the contract
     * @beta
     */
    getContract(address: string): Promise<SmartContract<import("contracts").ThirdwebContract>>;
    /**
     * Get an instance of a Custom contract from a json ABI
     * @param address - the address of the deployed contract
     * @param abi - the JSON abi
     * @returns the contract
     * @beta
     */
    getContractFromAbi(address: string, abi: ContractInterface): SmartContract<import("contracts").ThirdwebContract>;
    /**
     * @internal
     */
    getPublisher(): Promise<ContractPublisher>;
}
